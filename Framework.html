<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Raycasting with 3D View and Mini-map</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; background-color: #333; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Map configuration
    const map = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 1, 0, 1, 1, 1, 0, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];
    const mapWidth = map[0].length;
    const mapHeight = map.length;
    const blockSize = 64;
    const miniMapScale = 0.2;  // Smaller scale for the mini-map

    // Player configuration
    const player = {
        x: blockSize * 1.5,
        y: blockSize * 2.5,
        angle: Math.PI / 2,
        fov: Math.PI / 3,
        speed: 5
    };

    // Cast a single ray to find walls
    function castRay(angle) {
        let x = player.x;
        let y = player.y;
        const stepSize = 5;  // Smaller step for finer collision checks
        const deltaX = Math.cos(angle) * stepSize;
        const deltaY = Math.sin(angle) * stepSize;

        let distance = 0;
        while (true) {
            x += deltaX;
            y += deltaY;
            distance += stepSize;

            const mapX = Math.floor(x / blockSize);
            const mapY = Math.floor(y / blockSize);

            if (mapX < 0 || mapX >= mapWidth || mapY < 0 || mapY >= mapHeight || map[mapY][mapX] === 1) {
                const hitDistance = distance * Math.cos(angle - player.angle);  // Correct fish-eye effect
                return hitDistance;
            }
        }
    }

    // Render the 3D view
    function render3D() {
        for (let i = 0; i < canvas.width; i++) {
            const rayAngle = player.angle - player.fov / 2 + (player.fov * i / canvas.width);
            const dist = castRay(rayAngle);
            const wallHeight = canvas.height / dist;
            const offset = (canvas.height - wallHeight) / 2;  // Center the wall slice vertically

            ctx.fillStyle = `rgb(200, 200, 200)`;
            ctx.fillRect(i, offset, 1, wallHeight);  // Draw a vertical slice
        }
    }

    // Draw the mini-map
    function drawMiniMap() {
        const offsetX = canvas.width - (mapWidth * blockSize * miniMapScale) - 20;
        const offsetY = 20;

        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(miniMapScale, miniMapScale);

        for (let y = 0; y < mapHeight; y++) {
            for (let x = 0; x < mapWidth; x++) {
                ctx.fillStyle = map[y][x] === 1 ? 'red' : 'white';
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            }
        }

        // Draw the player on the mini-map
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(player.x, player.y, blockSize / 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // Handle keyboard input for player movement and rotation
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft')  player.angle -= 0.1;
        if (e.key === 'ArrowRight') player.angle += 0.1;
        if (e.key === 'ArrowUp') {
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;
        }
        if (e.key === 'ArrowDown') {
            player.x -= Math.cos(player.angle) * player.speed;
            player.y -= Math.sin(player.angle) * player.speed;
        }
    });

    // Game loop to update and render the scene
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        render3D();  // Render the 3D first-person view
        drawMiniMap();  // Draw the mini-map
        requestAnimationFrame(gameLoop);  // Continue the loop
    }

    gameLoop();
</script>
</body>
</html>
